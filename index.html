<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>PetGPT Ultimate Offline + Chunked GPT-2</title>
<style>
Â Â body { font-family: Arial, sans-serif; background: #1e1e1e; color: white; margin: 0; padding: 0; display: flex; flex-direction: column; height: 100vh; }
Â Â header, footer { background: #007acc; padding: 16px; text-align: center; font-size: 20px; }
Â Â #chat { flex: 1; overflow-y: auto; padding: 10px; background: #2b2b2b; }
Â Â .message { margin: 6px 0; padding: 8px; border-radius: 6px; max-width: 75%; word-wrap: break-word; }
Â Â .user { background: #3a3a3a; align-self: flex-end; }
Â Â .bot { background: #007acc; align-self: flex-start; }
Â Â #controls { display: flex; padding: 10px; background: #111; border-top: 1px solid #444; }
Â Â #userInput { flex: 1; padding: 8px; border: none; border-radius: 4px; background: #333; color: #eee; }
Â Â button { margin-left: 6px; padding: 8px 12px; border: none; border-radius: 4px; background: #007acc; color: #fff; cursor: pointer; }
Â Â #adminPanel { display: none; background: #333; padding: 10px; border-top: 2px solid #007acc; }
Â Â #adminPanel h4, #adminPanel label { margin: 6px 0; }
</style>
</head>
<body>
<header>ğŸ¾ PetGPT Ultimate Offline + Chunked GPT-2</header>

<div id="chat"></div>

<div id="controls">
Â Â <input id="userInput" placeholder="Type your message..." autocomplete="off" />
Â Â <button id="sendBtn">Send</button>
Â Â <button id="resetBtn">Reset Memory</button>
Â Â <button id="voiceBtn">ğŸ¤ Voice Chat</button>
</div>

<div id="adminPanel">
Â Â <h4>Admin Panel (type â€œcheetoâ€)</h4>
Â Â <label>Background Color: <input type="color" id="bgPicker" /></label>
</div>

<footer>Â© PetGPT Ultimate</footer>

<script src="https://cdn.jsdelivr.net/npm/@xenova/transformers@2.5.0/dist/transformers.min.js"></script>
<script>
(async () => {
Â Â // URLs for each chunk (21 parts)
Â Â const chunkUrls = [];
Â Â for (let i = 1; i <= 21; i++) {
Â Â Â Â chunkUrls.push(`files/gpt2/model.part${i}.bin`);
Â Â }
Â Â const modelConfigUrl = 'files/gpt2/model.json';

Â Â // UI elements
Â Â const chat = document.getElementById('chat');
Â Â const userInput = document.getElementById('userInput');
Â Â const sendBtn = document.getElementById('sendBtn');
Â Â const resetBtn = document.getElementById('resetBtn');
Â Â const voiceBtn = document.getElementById('voiceBtn');
Â Â const adminPanel = document.getElementById('adminPanel');
Â Â const bgPicker = document.getElementById('bgPicker');

Â Â // Memory storage
Â Â let memory = JSON.parse(localStorage.getItem('petgpt-memory') || '{}');

Â Â // Append message helper
Â Â function append(msg, cls) {
Â Â Â Â const d = document.createElement('div');
Â Â Â Â d.className = 'message ' + cls;
Â Â Â Â d.textContent = msg;
Â Â Â Â chat.appendChild(d);
Â Â Â Â chat.scrollTop = chat.scrollHeight;
Â Â }

Â Â function saveMem() {
Â Â Â Â localStorage.setItem('petgpt-memory', JSON.stringify(memory));
Â Â }

Â Â // Fetch and merge all binary chunks
Â Â async function fetchChunks(urls) {
Â Â Â Â const buffers = await Promise.all(urls.map(u => fetch(u).then(r => r.arrayBuffer())));
Â Â Â Â const totalLength = buffers.reduce((acc, b) => acc + b.byteLength, 0);
Â Â Â Â const merged = new Uint8Array(totalLength);
Â Â Â Â let offset = 0;
Â Â Â Â for (const buffer of buffers) {
Â Â Â Â Â Â merged.set(new Uint8Array(buffer), offset);
Â Â Â Â Â Â offset += buffer.byteLength;
Â Â Â Â }
Â Â Â Â return merged.buffer;
Â Â }

Â Â // Load model.json config
Â Â async function fetchJson(url) {
Â Â Â Â const res = await fetch(url);
Â Â Â Â return await res.json();
Â Â }

Â Â // Setup transformers environment to allow local buffers
Â Â window.transformers.env.allowLocalModels = true;

Â Â // Load tokenizer and model from merged buffer and config
Â Â let tokenizer, model;
Â Â let gptReady = false;

Â Â append("Loading GPT-2 model (chunked)... Please wait.", "bot");

Â Â try {
Â Â Â Â const modelConfig = await fetchJson(modelConfigUrl);
Â Â Â Â const modelBuffer = await fetchChunks(chunkUrls);

Â Â Â Â tokenizer = await window.transformers.AutoTokenizer.fromPretrained("gpt2");

Â Â Â Â model = await window.transformers.AutoModelForCausalLM.fromPretrained(null, {
Â Â Â Â Â Â config: modelConfig,
Â Â Â Â Â Â weights: modelBuffer,
Â Â Â Â });

Â Â Â Â gptReady = true;
Â Â Â Â append("GPT-2 model loaded successfully! Test worked!", "bot");
Â Â } catch (e) {
Â Â Â Â append("Failed to load GPT-2 model. Falling back to simple dictionary.", "bot");
Â Â Â Â console.error(e);
Â Â }

Â Â // Fallback simple dictionary
Â Â const fallbackModel = {
Â Â Â Â hello: "Hi there! How can I help you today?",
Â Â Â Â bye: "Goodbye! Have a great day!",
Â Â Â Â // add more as you want
Â Â };

Â Â // Generate reply with GPT-2 or fallback
Â Â async function getReply(text) {
Â Â Â Â const t = text.toLowerCase();

Â Â Â Â // teach command
Â Â Â Â if (t.startsWith('remember:')) {
Â Â Â Â Â Â const [k, v] = t.slice(9).split('=').map(s => s.trim());
Â Â Â Â Â Â if (k && v) {
Â Â Â Â Â Â Â Â memory[k] = v;
Â Â Â Â Â Â Â Â saveMem();
Â Â Â Â Â Â Â Â return `Got it! I'll remember ${k} = ${v}`;
Â Â Â Â Â Â }
Â Â Â Â Â Â return `Use: remember:key=value`;
Â Â Â Â }

Â Â Â Â // recall from memory
Â Â Â Â for (let k in memory) {
Â Â Â Â Â Â if (t.includes(k.toLowerCase())) return `You told me ${k} = ${memory[k]}`;
Â Â Â Â }

Â Â Â Â // admin unlock
Â Â Â Â if (t.includes('cheeto')) {
Â Â Â Â Â Â adminPanel.style.display = 'block';
Â Â Â Â Â Â return "Admin unlocked!";
Â Â Â Â }

Â Â Â Â if (gptReady) {
Â Â Â Â Â Â try {
Â Â Â Â Â Â Â Â const encoded = await tokenizer.encode(text);
Â Â Â Â Â Â Â Â const output = await model.generate(encoded.inputIds, {
Â Â Â Â Â Â Â Â Â Â max_new_tokens: 50,
Â Â Â Â Â Â Â Â Â Â do_sample: true,
Â Â Â Â Â Â Â Â Â Â temperature: 0.7,
Â Â Â Â Â Â Â Â Â Â top_p: 0.9,
Â Â Â Â Â Â Â Â });
Â Â Â Â Â Â Â Â const decoded = await tokenizer.decode(output[0]);
Â Â Â Â Â Â Â Â let reply = decoded.replace(text, '').trim();
Â Â Â Â Â Â Â Â if (!reply) reply = "Hmm, I don't know what to say.";
Â Â Â Â Â Â Â Â return reply;
Â Â Â Â Â Â } catch (e) {
Â Â Â Â Â Â Â Â console.error("GPT-2 generation error:", e);
Â Â Â Â Â Â }
Â Â Â Â }

Â Â Â Â // fallback
Â Â Â Â for (const key in fallbackModel) {
Â Â Â Â Â Â if (t.includes(key)) return fallbackModel[key];
Â Â Â Â }

Â Â Â Â return "Sorry, I don't understand.";
Â Â }

Â Â // Send message handler
Â Â async function sendMessage() {
Â Â Â Â const txt = userInput.value.trim();
Â Â Â Â if (!txt) return;
Â Â Â Â append("You: " + txt, 'user');
Â Â Â Â userInput.value = '';
Â Â Â Â userInput.disabled = true;
Â Â Â Â sendBtn.disabled = true;
Â Â Â Â try {
Â Â Â Â Â Â const reply = await getReply(txt);
Â Â Â Â Â Â append("PetGPT: " + reply, 'bot');
Â Â Â Â } catch {
Â Â Â Â Â Â append("PetGPT: Sorry, an error occurred.", 'bot');
Â Â Â Â } finally {
Â Â Â Â Â Â userInput.disabled = false;
Â Â Â Â Â Â sendBtn.disabled = false;
Â Â Â Â Â Â userInput.focus();
Â Â Â Â }
Â Â }

Â Â sendBtn.onclick = sendMessage;
Â Â userInput.addEventListener('keydown', e => {
Â Â Â Â if (e.key === 'Enter') {
Â Â Â Â Â Â e.preventDefault();
Â Â Â Â Â Â sendMessage();
Â Â Â Â }
Â Â });

Â Â // Reset memory/chat
Â Â resetBtn.onclick = () => {
Â Â Â Â if (confirm("Clear memory and chat?")) {
Â Â Â Â Â Â localStorage.clear();
Â Â Â Â Â Â memory = {};
Â Â Â Â Â Â chat.innerHTML = '';
Â Â Â Â Â Â append("Memory cleared.", "bot");
Â Â Â Â }
Â Â };

Â Â // Admin panel color picker
Â Â bgPicker.oninput = e => {
Â Â Â Â document.body.style.background = e.target.value;
Â Â };

Â Â // Voice chat setup
Â Â let recognition, recognizing = false;
Â Â if (window.SpeechRecognition || window.webkitSpeechRecognition) {
Â Â Â Â const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
Â Â Â Â recognition = new SR();
Â Â Â Â recognition.lang = 'en-US';
Â Â Â Â recognition.interimResults = false;
Â Â Â Â recognition.continuous = false;
Â Â Â Â recognition.onstart = () => { recognizing = true; voiceBtn.textContent = 'ğŸ›‘ Stop'; };
Â Â Â Â recognition.onend = () => { recognizing = false; voiceBtn.textContent = 'ğŸ¤ Voice Chat'; };
Â Â Â Â recognition.onerror = () => { recognizing = false; voiceBtn.textContent = 'ğŸ¤ Voice Chat'; };
Â Â Â Â recognition.onresult = e => {
Â Â Â Â Â Â const t = e.results[0][0].transcript;
Â Â Â Â Â Â userInput.value = t;
Â Â Â Â Â Â sendMessage();
Â Â Â Â };
Â Â }
Â Â voiceBtn.onclick = () => {
Â Â Â Â if (!recognition) return alert('SpeechRecognition not supported');
Â Â Â Â recognizing ? recognition.stop() : recognition.start();
Â Â };

Â Â userInput.focus();
})();
</script>
</body>
</html>
